#!/usr/bin/env python3
# =============================================================================
# COMPONENT: S.A.N.D.S. REPAIR AGENT
# -----------------------------------------------------------------------------
# Copyright 2026 Shuva Jyoti Kar 
# License: Apache 2.0
# =============================================================================
"""
S.A.N.D.S. Repair Agent: Write-Safe Interceptor
===============================================

Overview:
---------
In Agentic Systems, giving an LLM direct write access to the filesystem is a 
high-risk operation. LLMs frequently drop commas, leave unescaped quotes, or 
truncate outputs due to token limits, resulting in malformed JSON payloads.

This script implements the "Write-Safe Interceptor" pattern. It acts as a 
protective membrane between the LLM's output and the disk. More importantly, 
it drives the Cognitive Reflection Loop by converting Python stack traces into 
context-rich, actionable feedback that the LLM can use to self-correct.
"""

import json
import sys
import os
import argparse

def repair_and_write(filepath, content_str):
    """
    Validates a JSON string and safely writes it to disk, or returns targeted 
    telemetry to trigger an Agentic self-healing loop.

    Args:
        filepath (str): The destination path for the JSON file.
        content_str (str): The raw, potentially malformed JSON string generated by the LLM.
        
    Behavior:
        - If valid: Writes to disk and exits 0.
        - If invalid: Blocks the write, constructs a localized error snippet, 
          prints to stderr, and exits 1 to signal a tool failure to the Host Agent.
    """
    try:
        # =====================================================================
        # Step 1: In-Memory Validation (The Shield)
        # =====================================================================
        # We attempt to parse the string in memory BEFORE opening a file handler.
        # This prevents overwriting a known-good production config with a 
        # corrupted LLM hallucination.
        data = json.loads(content_str)
        
        # =====================================================================
        # Step 2: Atomic-style Write (The Commit)
        # =====================================================================
        # Auto-create missing parent directories to prevent OS-level path errors 
        # from confusing the LLM (which might assume its JSON was bad when 
        # really the folder was just missing).
        os.makedirs(os.path.dirname(os.path.abspath(filepath)), exist_ok=True)
        
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=4)
            
        # Standard Out is used for success signals.
        print(f"SUCCESS: Valid JSON safely committed to {filepath}")
        sys.exit(0)

    except json.JSONDecodeError as e:
        # =====================================================================
        # Step 3: The Cognitive Feedback Loop (The Compass)
        # =====================================================================
        # An LLM cannot fix "Invalid JSON". It needs spatial awareness.
        # We extract the exact line, column, and a 40-character sliding window 
        # around the syntax error. 
        # 
        # When the Host Agent feeds this `stderr` back into the LLM context, 
        # the LLM instantly recognizes the missing comma or unescaped quote 
        # and corrects it in the next ReAct turn.
        error_msg = (
            f"JSON_ERROR: {e.msg}\n"
            f"LOCATION: Line {e.lineno}, Column {e.colno}\n"
            f"SNIPPET: ...{content_str[max(0, e.pos-20):e.pos+20]}...\n"
            f"ACTION_REQUIRED: Please review the SNIPPET, fix the syntax error, and call this tool again."
        )
        
        # We write to standard error and exit with code 1. 
        # This hard-stops the execution and signals the Orchestrator that the 
        # tool invocation failed and requires a retry.
        print(error_msg, file=sys.stderr)
        sys.exit(1)
        
    except Exception as e:
        # Catch-all for unexpected OS errors (e.g., permission denied, disk full).
        print(f"SYSTEM_ERROR: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    # Command Line Interface designed for Host Agent subprocessing
    parser = argparse.ArgumentParser(description="Safely validates and writes JSON payloads.")
    parser.add_argument("--filepath", required=True, help="Target destination file path.")
    parser.add_argument("--content", required=True, help="Raw JSON string to validate and write.")
    args = parser.parse_args()
    
    repair_and_write(args.filepath, args.content)
